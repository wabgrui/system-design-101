

<!-- TOC toc.levels=2 -->

- 通信协议

  - [REST API 与 GraphQL](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#rest-api-vs-graphql)
  - [gRPC 是如何工作的？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-does-grpc-work)
  - [什么是 Webhook？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#what-is-a-webhook)
  - [如何提高 API 性能？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-to-improve-api-performance)
  - [HTTP 1.0 -> HTTP 1.1 -> HTTP 2.0 ->HTTP 3.0 （QUIC）](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#http-10---http-11---http-20---http-30-quic)
  - [SOAP vs REST vs GraphQL vs RPC](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#soap-vs-rest-vs-graphql-vs-rpc)
  - [代码优先与 API 优先](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#code-first-vs-api-first)
  - [HTTP 状态代码](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#http-status-codes)
  - [API 网关有什么作用？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#what-does-api-gateway-do)
  - [我们如何设计有效且安全的 API？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-do-we-design-effective-and-safe-apis)
  - [TCP/IP 封装](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#tcpip-encapsulation)
  - [为什么 Nginx 被称为“反向”代理？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#why-is-nginx-called-a-reverse-proxy)
  - [常见的负载均衡算法有哪些？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#what-are-the-common-load-balancing-algorithms)
  - [URL、URI、URN - 你知道其中的区别吗？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#url-uri-urn---do-you-know-the-differences)

- CI/CD

  - [CI/CD 管道简单解释](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#cicd-pipeline-explained-in-simple-terms)
  - [Netflix 技术堆栈（CI/CD 管道）](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#netflix-tech-stack-cicd-pipeline)

- 体系结构模式

  - [MVC、MVP、MVVM、MVVM-C 和 VIPER](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#mvc-mvp-mvvm-mvvm-c-and-viper)
  - [每个开发人员都应该知道的 18 种关键设计模式](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#18-key-design-patterns-every-developer-should-know)

- 数据库

  - [云服务中不同数据库的漂亮备忘单](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#a-nice-cheat-sheet-of-different-databases-in-cloud-services)
  - [为数据库提供支持的 8 种数据结构](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#8-data-structures-that-power-your-databases)
  - [SQL语句是如何在数据库中执行的？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-is-an-sql-statement-executed-in-the-database)
  - [CAP定理](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#cap-theorem)
  - [内存和存储的类型](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#types-of-memory-and-storage)
  - [可视化 SQL 查询](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#visualizing-a-sql-query)
  - [SQL 语言](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#sql-language)

- 缓存

  - [数据缓存在任何地方](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#data-is-cached-everywhere)
  - [为什么 Redis 这么快？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#why-is-redis-so-fast)
  - [如何使用 Redis？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-can-redis-be-used)
  - [顶级缓存策略](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#top-caching-strategies)

- 微服务架构

  - [典型的微服务架构是什么样的？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#what-does-a-typical-microservice-architecture-look-like)
  - [微服务最佳实践](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#microservice-best-practices)
  - [微服务通常使用什么技术堆栈？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#what-tech-stack-is-commonly-used-for-microservices)
  - [为什么 Kafka 速度快](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#why-is-kafka-fast)

- 支付系统

  - [如何学习支付系统？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-to-learn-payment-systems)
  - [为什么信用卡被称为“银行中最赚钱的产品”？VISA/万事达卡如何赚钱？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#why-is-the-credit-card-called-the-most-profitable-product-in-banks-how-does-visamastercard-make-money)
  - [当我们在商家商店刷信用卡时，VISA是如何运作的？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-does-visa-work-when-we-swipe-a-credit-card-at-a-merchants-shop)
  - [全球支付系统系列（第 1 部分）：印度的统一支付接口 （UPI）](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#payment-systems-around-the-world-series-part-1-unified-payments-interface-upi-in-india)

- DevOps的

  - [DevOps、SRE 与平台工程。有什么区别？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#devops-vs-sre-vs-platform-engineering-what-is-the-difference)
  - [什么是 k8s （Kubernetes）？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#what-is-k8s-kubernetes)
  - [Docker 与 Kubernetes。我们应该使用哪一个？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#docker-vs-kubernetes-which-one-should-we-use)
  - [Docker 是如何工作的？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-does-docker-work)

- GIT

  - [Git 命令的工作原理](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-git-commands-work)
  - [Git 是如何工作的？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-does-git-work)
  - [Git 合并与 Git 变基](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#git-merge-vs-git-rebase)

- 云服务

  - [不同云服务的精彩备忘单（2023 版）](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#a-nice-cheat-sheet-of-different-cloud-services-2023-edition)
  - [什么是云原生？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#what-is-cloud-native)

- 开发人员生产力工具

  - [可视化 JSON 文件](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#visualize-json-files)
  - [自动将代码转换为架构图](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#automatically-turn-code-into-architecture-diagrams)

- Linux操作系统

  - [Linux 文件系统解释](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#linux-file-system-explained)
  - [您应该知道的 18 个最常用的 Linux 命令](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#18-most-used-linux-commands-you-should-know)

- 安全

  - [HTTPS是如何工作的？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-does-https-work)
  - [Oauth 2.0 用简单的术语解释。](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#oauth-20-explained-with-simple-terms)
  - [身份验证机制的 4 大形式](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#top-4-forms-of-authentication-mechanisms)
  - [会话、Cookie、JWT、令牌、SSO 和 OAuth 2.0 - 它们是什么？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#session-cookie-jwt-token-sso-and-oauth-20---what-are-they)
  - [如何将密码安全地存储在数据库中以及如何验证密码？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-to-store-passwords-safely-in-the-database-and-how-to-validate-a-password)
  - [向 10 岁的孩子解释 JSON Web 令牌 （JWT）](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#explaining-json-web-token-jwt-to-a-10-year-old-kid)
  - [Google 身份验证器（或其他类型的双因素身份验证器）如何工作？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-does-google-authenticator-or-other-types-of-2-factor-authenticators-work)

- 真实世界案例研究

  - [Netflix 的技术栈](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#netflixs-tech-stack)

  - [Twitter 架构 2022](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#twitter-architecture-2022)

  - [Airbnb 微服务架构在过去 15 年的演变](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#evolution-of-airbnbs-microservice-architecture-over-the-past-15-years)

  - [Monorepo 与 Microrepo。](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#monorepo-vs-microrepo)

  - [您将如何设计 Stack Overflow 网站？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-will-you-design-the-stack-overflow-website)

  - [为什么 Amazon Prime Video 监控从无服务器转变为单体监控？如何节省90%的成本？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#why-did-amazon-prime-video-monitoring-move-from-serverless-to-monolithic-how-can-it-save-90-cost)

  - [Disney Hotstar 如何在锦标赛期间捕获 50 亿个表情符号？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-does-disney-hotstar-capture-5-billion-emojis-during-a-tournament)

  - [Discord 如何存储数万亿条消息](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-discord-stores-trillions-of-messages)

  - [视频直播如何在 YouTube、TikTok 直播或 Twitch 上进行？](https://github.com/wabgrui/system-design-101?tab=readme-ov-file#how-do-video-live-streamings-work-on-youtube-tiktok-live-or-twitch)

    <!-- /TOC -->

# 通信协议

架构定义了应用程序编程接口 （API） 的不同组件如何相互交互。因此，它们通过提供设计和构建 API 的标准方法，确保效率、可靠性和与其他系统的易集成性。以下是最常用的样式：

<p>
  <img src="images/api-architecture-styles.png" style="width: 640px">
</p>

- SOAP:

成熟、全面、基于xml的最适合企业应用程序

- rest:

流行的、易于实现的HTTP方法是web服务的理想选择

- GraphQL:

查询语言，请求特定数据减少网络开销，更快的响应

- gRPC:

适用于微服务架构的现代、高性能协议缓冲区

- WebSocket:

实时，双向，持久连接完美的低延迟数据交换

- Webhook:

事件驱动，HTTP回调，当事件发生时异步通知系统

### REST API vs. GraphQL

在API设计方面，REST和GraphQL各有优缺点。下图显示了REST和GraphQL之间的快速比较。

<p>
  <img src="images/graphQL.jpg">
</p>


REST

-使用标准的HTTP方法，如GET, POST, PUT, DELETE进行CRUD操作。
-当您需要在单独的服务/应用程序之间提供简单、统一的接口时，可以很好地工作。
-缓存策略很容易实现。
-缺点是可能需要多次往返才能从不同的端点组装相关数据。

GraphQL

-为客户端提供一个端点来查询他们所需要的数据。
-客户端指定嵌套查询中所需的确切字段，服务器返回包含这些字段的优化有效负载。
-支持修改数据的“突变”和实时通知的“订阅”。
-非常适合聚合来自多个来源的数据，并能很好地应对快速发展的前端需求。
-然而，它将复杂性转移到客户端，如果没有适当的保护，可能会允许滥用查询
-缓存策略可能比REST更复杂。

REST和GraphQL之间的最佳选择取决于应用程序和开发团队的具体需求。GraphQL非常适合复杂或经常变化的前端需求，而REST适合那些更喜欢简单和一致协议的应用程序。

这两种API方法都不是灵丹妙药。仔细评估需求和权衡对于选择正确的风格非常重要。REST和GraphQL都是公开数据和支持现代应用程序的有效选项。

### How does gRPC work?

RPC(远程过程调用)被称为“远程”，因为在微服务架构下，当服务部署到不同的服务器上时，它支持远程服务之间的通信。从用户的角度来看，它就像一个本地函数调用。

下图说明了**gRPC**的总体数据流。

<p>
  <img src="images/grpc.jpg">
</p>

步骤1:从客户端发出REST调用。请求主体通常是JSON格式。

步骤2 - 4:订单服务(gRPC客户端)接收REST调用，对其进行转换，并对支付服务进行RPC调用。gRPC将客户端存根编码成二进制格式，并将其发送到底层传输层。

步骤5:gRPC通过网络通过HTTP2发送报文。由于二进制编码和网络优化，据说gRPC比JSON快5倍。

步骤6 ~ 8:支付服务(gRPC服务器)接收来自网络的报文，解码后调用服务器应用程序。

步骤9 - 11:结果从服务器应用程序返回，并被编码并发送到传输层。

步骤12 - 14:订单服务接收数据包，对其进行解码，并将结果发送给客户机应用程序。

### What is a webhook?

下图显示了轮询和Webhook之间的比较。

<p>
  <img src="images/webhook.jpeg" style="width: 680px" />
</p>

假设我们经营一个电子商务网站。客户端通过API网关将订单发送到订单服务，该网关转到支付服务进行支付交易。然后，支付服务与外部支付服务提供者(PSP)对话以完成交易。

这里是两种方法可以处理与外部PSP的通信。

1.**短的轮询**

在向PSP发送支付请求后，支付服务不断询问PSP的支付状态。经过几轮后，PSP终于带着状态返回。

短轮询有两个缺点:

*持续的状态轮询需要支付服务的资源。
*外部服务直接与支付服务通信，造成安全漏洞。

2.**Webhook** 

我们可以用外部服务注册一个webhook。它的意思是:当你对请求有更新时，在某个URL给我回电话。当PSP完成处理后，它将调用HTTP请求来更新支付状态。

通过这种方式，改变了编程范例，并且支付服务不再需要浪费资源来轮询支付状态。

如果PSP再也不回电话怎么办?我们可以设置一个管家工作，每小时检查一次付款状态。

webhook通常被称为反向api或推送api，因为服务器向客户端发送HTTP请求。在使用webhook时，我们需要注意3件事:

1. 我们需要为外部服务调用设计合适的API。
2. 出于安全原因，我们需要在API网关中设置适当的规则。
3. 我们需要在外部服务中注册正确的URL。

### How to improve API performance?

<p>
  <img src="images/api-performance.jpg">
</p>

分页

当结果的大小很大时，这是一种常见的优化。结果流回客户端以提高服务响应性。

异步日志

同步日志为每次调用处理磁盘，可能会降低系统的运行速度。异步日志首先将日志发送到无锁缓冲区，然后立即返回。日志将定期刷新到磁盘中。这大大减少了I/O开销。

缓存

我们可以将频繁访问的数据存储在缓存中。客户端可以先查询缓存，而不是直接访问数据库。如果缓存丢失，客户端可以从数据库进行查询。像Redis这样的缓存将数据存储在内存中，因此数据访问比数据库快得多。

有效载荷压缩

请求和响应可以使用gzip等压缩，这样传输的数据大小就小得多。这加快了上传和下载的速度。

连接池

在访问资源时，我们经常需要从数据库加载数据。打开正在关闭的db连接会增加很大的开销。因此，我们应该通过一个打开的连接池连接到数据库。连接池负责管理连接生命周期。

### HTTP 1.0 -> HTTP 1.1 -> HTTP 2.0 -> HTTP 3.0 (QUIC)

<p>
  <img src="images/http3.jpg" />
</p>

- HTTP 1.0在1996年完成并完整文档化。对同一服务器的每个请求都需要一个单独的TCP连接。


- HTTP 1.1于1997年发布。TCP连接可以保持打开状态以供重用(持久连接)，但它不能解决HOL(排队头)阻塞问题。


HOL阻塞——当浏览器中允许的并行请求数用完时，后续请求需要等待前一个请求完成。

- HTTP 2.0于2015年发布。它通过请求多路复用来解决HOL问题，这消除了应用层的HOL阻塞，但在传输(TCP)层仍然存在HOL。

如图所示，HTTP 2.0引入了HTTP“流”的概念:一种抽象，允许将不同的HTTP交换多路复用到相同的TCP连接上。每个流不需要按顺序发送。

- HTTP 3.0初稿于2020年发布。它是HTTP 2.0的建议继承者。它使用QUIC而不是TCP作为底层传输协议，从而消除了传输层中的HOL阻塞。

QUIC基于UDP协议。它将流作为一等公民引入传输层。QUIC流共享相同的QUIC连接，因此不需要额外的握手和缓慢启动来创建新的QUIC连接，但是QUIC流是独立交付的，因此在大多数情况下，影响一个流的数据包丢失不会影响其他流。

### SOAP vs REST vs GraphQL vs RPC

下图说明了 API 时间轴和 API 风格比较。

随着时间的推移，不同的 API 架构风格相继问世。每种风格都有自己的数据交换标准化模式。

您可以在图中查看每种风格的使用案例。

<p>
  <img src="images/SOAP vs REST vs GraphQL vs RPC.jpeg" />
</p>

### Code First vs. API First 

下图显示了代码优先开发和 API 优先开发之间的区别。为什么要考虑 API 优先设计？

<p>
  <img src="images/api_first.jpg" style="width: 680px" />
</p>

- 微服务增加了系统的复杂性，我们需要单独的服务来服务于系统的不同功能。虽然这种架构有利于解耦和职责分离，但我们需要处理服务之间的各种通信。

在编写代码和仔细定义服务边界之前，最好先考虑清楚系统的复杂性。

- 独立的职能团队需要使用同一种语言，专门的职能团队只对自己的组件和服务负责。建议组织通过应用程序接口设计使用同一种语言。

我们可以模拟请求和响应，在编写代码前验证 API 设计。

- 提高软件质量和开发人员的工作效率 由于我们在项目开始时就消除了大部分不确定因素，因此整个开发过程会更加顺利，软件质量也会大大提高。

开发人员对这一过程也很满意，因为他们可以专注于功能开发，而不是商讨突然的变化。

在项目生命周期结束时出现意外的可能性也会降低。

由于我们首先设计了应用程序接口，因此可以在开发代码的同时设计测试。在某种程度上，使用 API 优先开发时，我们还可以进行 TDD（测试驱动设计）。

### HTTP status codes

<p>
  <img src="images/http-status-code.jpg" style="width: 540px" />
</p>

HTTP 的响应代码分为五类： 

信息（100-199） 
成功（200-299） 
重定向（300-399） 
客户端错误（400-499） 
服务器错误（500-599）

### What does API gateway do? 

<p>
  <img src="images/api_gateway.jpg" style="width: 520px" />
</p>

第 1 步 - 客户端向 API 网关发送 HTTP 请求。

第 2 步 - API 网关解析并验证 HTTP 请求中的属性。

第 3 步 - API 网关执行允许列表/拒绝列表检查。

第 4 步：API 网关与身份提供商对话，进行身份验证和授权。

第 5 步 - 将速率限制规则应用于请求。如果超过限制，请求将被拒绝。

第 6 步和第 7 步 - 既然请求已通过基本检查，API 网关就会通过路径匹配找到要路由的相关服务。

第 8 步：API 网关将请求转换为适当的协议，并将其发送到后端微服务。

第 9-12 步： API 网关可以正确处理错误，并在错误需要较长时间恢复（断路）时处理故障。它还可以利用 ELK（Elastic-Logstash-Kibana）栈进行日志记录和监控。我们有时会在 API 网关中缓存数据。

### How do we design effective and safe APIs?

<p>
  <img src="images/safe-apis.jpg" />
</p>

请注意，应用程序接口设计不仅仅是 URL 路径设计。大多数时候，我们需要选择合适的资源名称、标识符和路径模式。设计适当的 HTTP 头域或在 API 网关中设计有效的速率限制规则也同样重要。

### TCP/IP encapsulation 

数据如何通过网络发送？为什么 OSI 模型需要这么多层？

下图显示了数据在网络上传输时的封装和解封过程。

<p>
  <img src="images/osi model.jpeg" />
</p>

步骤 1：当设备 A 通过 HTTP 协议在网络上向设备 B 发送数据时，首先会在应用层添加一个 HTTP 标头。

步骤 2：然后在数据中添加 TCP 或 UDP 标头。它在传输层被封装成 TCP 段。报头包含源端口、目的端口和序列号。

步骤 3：然后在网络层用 IP 报头对这些段落进行封装。IP 报头包含源/目的 IP 地址。

步骤 4：在数据链路层为 IP 数据报添加 MAC 报头，其中包含源/目的 MAC 地址。

第 5 步：封装后的帧被发送到物理层，并以二进制位在网络上发送。

步骤 6-10： 设备 B 从网络接收到比特后，会执行去封装过程，这是对封装过程的逆向处理。数据头被逐层删除，最终，设备 B 可以读取数据。

在网络模型中，我们需要层，因为每一层都专注于自己的职责。每一层都可以依靠报头来处理指令，而不需要知道上一层数据的含义。

### Why is Nginx called a “reverse” proxy?

<p>
  <img src="images/Forward Proxy v.s. Reverse Proxy2x.jpg" style="width: 720px" />
</p>

前向代理是位于用户设备和互联网之间的服务器。

前向代理通常用于 

1. 保护客户端
2. 规避浏览限制
3. 阻止访问某些内容

反向代理是一种服务器，它接受客户端的请求，将请求转发给网络服务器，然后将结果返回给客户端，就像代理服务器处理了请求一样。

反向代理可用于

1. 保护服务器
2. 负载平衡
3. 缓存静态内容
4. 加密和解密 SSL 通信

### What are the common load-balancing algorithms?

<p>
  <img src="images/lb-algorithms.jpg" />
</p>

- 静态算法 

1. 循环

   客户请求按顺序发送到不同的服务实例。通常要求服务是无状态的。

2. 粘性循环

   这是对循环算法的一种改进。如果 Alice 的第一个请求发送到服务 A，那么接下来的请求也会发送到服务 A。

3. 加权循环

   管理员可以指定每个服务的权重。权重高的服务会比其他服务处理更多请求。

4. 散列

   该算法对传入请求的 IP 或 URL 应用哈希函数。根据哈希函数的结果，将请求路由到相关实例。

- 动态算法

5. 最少连接

   新请求会发送到并发连接最少的服务实例。

6. 响应时间最少

   向响应时间最快的服务实例发送新请求。

### URL, URI, URN - Do you know the differences? 

<p>
  <img src="images/url-uri-urn.jpg" />
</p>

- URI 

URI 是统一资源标识符（Uniform Resource Identifier）的缩写。它标识网络上的逻辑或物理资源。URL 和 URN 是 URI 的子类型。URL 用于定位资源，而 URN 用于命名资源。

URI 由以下部分组成： 
方案:[//授权]路径[?查询][#片段］ 

- URL 

URL 代表统一资源定位器，是 HTTP 的关键概念。它是网络上唯一资源的地址。它可与 FTP 和 JDBC 等其他协议一起使用。

- URN 

URN 代表统一资源名称。它使用 URN 方案。URN 不能用于定位资源。图中给出的一个简单示例由一个命名空间和一个命名空间特定字符串组成。

如果您想了解有关该主题的更多详情，我推荐您阅读 [W3C 的说明](https://www.w3.org/TR/uri-clarification/)。

## CI/CD

CI/CD Pipeline Explained in Simple Terms

<p>
  <img src="images/ci-cd-pipeline.jpg" style="width: 680px" />
</p>

第 1 节 - 使用 CI/CD 的 SDLC

软件开发生命周期（SDLC）包括几个关键阶段：开发、测试、部署和维护。CI/CD 对这些阶段进行自动化和集成，以实现更快、更可靠的发布。

当代码被推送到 git 仓库时，就会触发自动构建和测试流程。运行端到端（e2e）测试用例来验证代码。如果测试通过，代码就能自动部署到暂存/生产阶段。如果发现问题，代码将被送回开发部门进行错误修复。这种自动化可为开发人员提供快速反馈，并降低生产中出现错误的风险。

第 2 节 - CI 与 CD 的区别

持续集成（CI）将构建、测试和合并流程自动化。每当提交代码时，它都会运行测试，以便及早发现集成问题。这鼓励了频繁的代码提交和快速反馈。

持续交付（CD）可自动执行发布流程，如基础架构变更和部署。它通过自动化工作流程确保软件可以随时可靠地发布。CD 还可以自动执行生产部署前所需的手动测试和审批步骤。

第 3 节 - CI/CD 管道

典型的 CI/CD 流水线有几个相互连接的阶段：

- 开发人员向源代码控制提交代码变更
- CI 服务器检测更改并触发构建
- 编译代码并进行测试（单元测试、集成测试）
- 向开发人员报告测试结果
- 成功后，将工件部署到暂存环境中
- 发布前可在暂存环境中进行进一步测试
- CD 系统将批准的变更部署到生产环境

### Netflix Tech Stack (CI/CD Pipeline)

<p>
  <img src="images/netflix-ci-cd.jpg" style="width: 720px" />
</p>

规划： Netflix 工程部使用 JIRA 进行规划，使用 Confluence 编写文档。

编码： Java 是后端服务的主要编程语言，其他语言用于不同的用例。 

构建： 主要使用 Gradle 进行构建，并构建 Gradle 插件以支持各种用例。 

打包： 将软件包和依赖项打包到亚马逊机器映像（AMI）中，以便发布。

测试： 测试强调生产文化对构建混乱工具的关注。 

部署： Netflix 使用自建的 Spinnaker 进行金丝雀式推出部署。 

监控： 监控指标集中在 Atlas 中，Kayenta 用于检测异常情况。 

事件报告： 根据优先级派遣事件，并使用 PagerDuty 进行事件处理。

## Architecture patterns

### MVC, MVP, MVVM, MVVM-C, and VIPER

无论是 iOS 还是 Android 平台，这些架构模式都是应用程序开发中最常用的模式之一。开发人员引入这些模式是为了克服早期模式的局限性。那么，它们有什么不同呢？

<p>
  <img src="images/client arch patterns.png" style="width: 720px" />
</p>

- MVC 是最古老的模式，可追溯到近 50 年前 
- 每种模式都有一个 "视图"（V），负责显示内容和接收用户输入 
- 大多数模式都包含一个 "模型"（M）来管理业务数据 
- 控制器"、"展示器 "和 "视图-模型 "是视图和模型（VIPER 模式中的 "实体"）之间的翻译器

### 18 Key Design Patterns Every Developer Should Know

<p>
  <img src="images/18-oo-patterns.png" />
</p>

- 抽象工厂： Family Creator（家族创建器）--创建相关项目组。
- 构建器 乐高大师 - 逐步构建对象，将创建和外观分开。
- 原型： 克隆制作器 - 创建完全准备好的示例副本。
- 单例 独一无二 - 只有一个实例的特殊类。
- 适配器 通用插头 - 连接具有不同接口的事物。
- 桥： 功能连接器 - 将对象的工作方式与功能联系起来。
- Composite： 树形生成器--形成由简单和复杂部分组成的树形结构。
- Decorator： 定制器 - 在不改变对象核心的情况下为其添加功能。
- 门面 One-Stop-Shop （一站式服务）- 用单一、简化的界面代表整个系统。
- Flyweight： 节省空间--有效共享可重复使用的小型项目。
- 代理 代理（Stand-In Actor）--代表另一个对象，控制访问或操作。
- 责任链： 请求中继--通过对象链传递请求，直至处理完毕。
- 命令 任务包装器 - 将请求转化为对象，以便随时采取行动。
- 迭代器 集合浏览器 - 逐个访问集合中的元素。
- 调解器 通信枢纽--简化不同类之间的交互。
- Memento：时间胶囊 时间胶囊--捕捉并恢复对象的状态。
- 观察者 新闻播报员--通知类其他对象的变化。
- Visitor： Skillful Guest - 在不改变类的情况下为类添加新的操作。

## Database

### A nice cheat sheet of different databases in cloud services

<p>
  <img src="images/cloud-dbs2.png" />
</p>

### 8 Data Structures That Power Your Databases

答案因使用情况而异。数据可以在内存或磁盘中建立索引。同样，数据格式也各不相同，如数字、字符串、地理坐标等。系统可能重写，也可能重读。所有这些因素都会影响数据库索引格式的选择。

<p>
  <img src="images/8-ds-db.jpg" />
</p>

以下是一些最常用的索引数据结构： 

- Skiplist：一种常见的内存索引类型。在 Redis 中使用 
- 哈希索引："Map "数据结构（或 "Collection"）的一种常见实现 
- SSTable：磁盘上不可变的 "映射 "实现 
- LSM 树： Skiplist + SSTable。高写入吞吐量 
- B 树：基于磁盘的解决方案。读/写性能稳定 
- 倒排索引：用于文档索引。在 Lucene 中使用 
- 后缀树：用于字符串模式搜索 
- R 树：多维度搜索，如查找最近的邻居

### How is an SQL statement executed in the database?

<p>
  <img src="images/sql execution order in db.jpeg" style="width: 580px" />
</p>

第 1 步 - 通过传输层协议（如 TCP）向数据库发送 SQL 语句。

第 2 步 - 将 SQL 语句发送到命令解析器，对其进行语法和语义分析，然后生成查询树。

第 3 步 - 将查询树发送给优化器。优化器会创建一个执行计划。

第 4 步 - 将执行计划发送给执行器。执行器从执行计划中获取数据。

第 5 步 - 访问方法提供执行所需的数据获取逻辑，从存储引擎获取数据。

第 6 步：访问方法决定 SQL 语句是否只读。如果查询是只读的（SELECT 语句），则将其传递给缓冲区管理器进行进一步处理。缓冲区管理器会在缓存或数据文件中查找数据。

第 7 步 - 如果语句是 UPDATE 或 INSERT，则将其传递给事务管理器作进一步处理。

第 8 步 - 在事务处理期间，数据处于锁定模式。这是由锁管理器保证的。它还能确保事务的 ACID 属性。

### CAP theorem

<p>
  <img src="images/cap theorem.jpeg" />
</p>

CAP 定理指出，分布式系统不能同时提供这三种保证中的两种以上。

**一致性**：一致性意味着所有客户端无论连接到哪个节点，都能在同一时间看到相同的数据。

**可用性**：可用性是指即使部分节点宕机，任何请求数据的客户端都能得到响应。

**分区容忍度**：分区表示两个节点之间的通信中断。分区容错是指即使出现网络分区，系统也能继续运行。

“3 选2 "的表述可能有用，**但这种简化可能会误导**。

1. 选择数据库并非易事。仅仅根据 CAP 定理来证明我们的选择是不够的。例如，公司不会仅仅因为 Cassandra 是 AP 系统就为聊天应用选择它。Cassandra 有一系列优良特性，是存储聊天信息的理想选择。我们需要深入挖掘。

2. "CAP 只禁止了设计空间的一小部分：在分区存在的情况下具有完美的可用性和一致性，而这种情况很少见"。引自论文： 十二年后的 CAP： 规则 "是如何改变的》。

3. 该定理是关于 100% 可用性和一致性的。更现实的讨论是在没有网络分区时，延迟与一致性之间的权衡。详见 PACELC 定理。

**Is the CAP theorem actually useful?**

我认为它仍然有用，因为它为我们提供了一系列权衡讨论的思路，但它只是故事的一部分。在选择合适的数据库时，我们需要深入挖掘。

### Types of Memory and Storage

<p>
  <img src="images/Types_of_Memory_and_Storage.jpeg" style="width: 420px" />
</p>

### Visualizing a SQL query

<p>
  <img src="images/sql-execution-order.jpg" style="width: 580px" />
</p>

数据库系统执行 SQL 语句有几个步骤，包括 

- 解析 SQL 语句并检查其有效性 
- 将 SQL 转换为内部表示，如关系代数 
- 优化内部表示法，并创建一个利用索引信息的执行计划 
- 执行计划并返回结果 

SQL 的执行非常复杂，需要考虑很多因素，例如 

- 索引和缓存的使用 
- 表连接的顺序 
- 并发控制 
- 事务管理

### SQL language 

1986 年，SQL（结构化查询语言）成为一种标准。在接下来的 40 年里，它成为关系数据库管理系统的主流语言。阅读最新标准（ANSI SQL 2016）可能很费时间。如何学习？

<p>
  <img src="images/how-to-learn-sql.jpg" />
</p>

SQL 语言有 5 个组成部分： 

- DDL：数据定义语言，如 CREATE、ALTER、DROP 
- DQL：数据查询语言，如 SELECT 
- DML：数据操作语言，如 INSERT、UPDATE、DELETE 
- DCL：数据控制语言，如 GRANT、REVOKE 
- TCL：事务控制语言，如 COMMIT、ROLLBACK 

对于后端工程师来说，您可能需要了解其中的大部分内容。作为一名数据分析师，你可能需要充分了解 DQL。选择与您最相关的主题。

## Cache

### Data is cached everywhere

<p>
  <img src="images/where do we cache data.jpeg" style="width: 720px" />
</p>

这里有**多层**。

1. 客户端应用程序：浏览器可以缓存 HTTP 响应。我们第一次通过 HTTP 请求数据时，HTTP 头会返回一个过期策略；我们再次请求数据时，客户端应用程序会尝试先从浏览器缓存中检索数据。
2. CDN：CDN 缓存静态网络资源。客户端可以从附近的 CDN 节点获取数据。
3. 负载平衡器： 负载平衡器也可以缓存资源。
4. 消息传递基础设施： 消息代理首先将消息存储在磁盘上，然后消费者按自己的节奏检索消息。根据保留策略，数据会在 Kafka 集群中缓存一段时间。
5. 服务： 服务中有多层缓存。如果 CPU 缓存中没有缓存数据，服务就会尝试从内存中检索数据。有时，服务会有一个二级缓存，将数据存储在磁盘上。
6. 分布式缓存： 分布式缓存（如 Redis）可在内存中保存多个服务的键值对。它的读/写性能比数据库好得多。
7. 全文搜索：我们有时需要使用全文搜索（如用于文档搜索或日志搜索的 Elastic Search）。搜索引擎中也会索引数据副本。
8. 数据库： 即使在数据库中，我们也有不同级别的缓存：

- WAL（先写日志）：数据先写入 WAL，然后再建立 B 树索引
- 缓冲池： 分配给缓存查询结果的内存区域
- 物化视图： 预先计算查询结果并将其存储在数据库表中，以提高查询性能
- 事务日志：记录所有事务和数据库更新
- 复制日志：用于记录数据库集群中的复制状态

### Why is Redis so fast? 

<p>
  <img src="images/top-redis-use-cases.jpg" style="width: 520px" />
</p>

Redis 不仅仅是缓存。

如图所示，Redis 可用于多种场景。

- 会话 

  我们可以使用 Redis 在不同服务之间共享用户会话数据。

- 缓存 

  我们可以使用 Redis 来缓存对象或页面，尤其是热点数据。

- 分布式锁 

  我们可以使用 Redis 字符串在分布式服务之间获取锁。

- 计数器 

  我们可以计算文章的点赞数或阅读数。

- 速率限制器 

  我们可以为某些用户 IP 设置速率限制器。

- 全局 ID 生成器 

### Top caching strategies

<p>
  <img src="images/top_caching_strategy.jpeg" style="width: 680px" />
</p>

## Microservice architecture

### What does a typical microservice architecture look like? 

<p>
  <img src="images/typical-microservice-arch.jpg" style="width: 520px" />
</p>

下图显示了一个典型的微服务架构。

- 负载平衡器： 它在多个后端服务之间分配传入流量。
- CDN（内容分发网络）： CDN 是一组分布在不同地理位置的服务器，用于保存静态内容以加快交付速度。客户端首先在 CDN 中查找内容，然后再转到后端服务。
- API 网关： 它处理传入的请求，并将其路由到相关服务。它与身份提供商和服务发现进行对话。
- 身份供应商： 处理用户的身份验证和授权。
- 服务注册与发现： 微服务注册和发现在此组件中进行，API 网关在此组件中寻找相关服务进行对话。
- 管理： 该组件负责监控服务。
- 微服务： 微服务在不同的域中设计和部署。每个域都有自己的数据库。API 网关通过 REST API 或其他协议与微服务对话，同一域内的微服务通过 RPC（远程过程调用）相互对话。

微服务的优势：

- 它们可以快速设计、部署和横向扩展。
- 每个域都可以由专门的团队独立维护。
- 业务需求可以在每个域中定制，并因此得到更好的支持。

### Microservice Best Practices

<p>
  <img src="images/microservice-best-practices.jpeg" />
</p>

在开发微服务时，我们需要遵循以下最佳实践： 

1. 为每个微服务使用单独的数据存储 
2. 让代码保持相似的成熟度 
3. 每个微服务单独构建 
4. 为每个微服务分配单一职责 
5. 部署到容器中 
6. 设计无状态服务 
7. 采用领域驱动设计
8. 设计微型前端 
9. 协调微服务

### What tech stack is commonly used for microservices?

<p>
  <img src="images/microservice-tech.jpeg" />
</p>

▶️ 𝐏𝐫𝐞-𝐏𝐫𝐨𝐝𝐮𝐜𝐭𝐢𝐨𝐧

- 定义应用程序接口（API）--这将在前端和后端之间建立合约。为此，我们可以使用 Postman 或 OpenAPI。
- 开发 - Node.js 或 react 用于前端开发，而 java/python/go 用于后端开发。此外，我们还需要根据 API 定义更改 API 网关中的配置。
- 持续集成 - JUnit 和 Jenkins 用于自动化测试。代码打包成 Docker 镜像并作为微服务部署。

▶️ 𝐏𝐫𝐨𝐝𝐮𝐜𝐭𝐢𝐨𝐧

- NGinx 是负载平衡器的常见选择。Cloudflare 提供 CDN（内容分发网络）。
- API 网关--我们可以使用 Spring Boot 作为网关，并使用 Eureka/Zookeeper 进行服务发现。
- 微服务部署在云上。我们可以选择 AWS、Microsoft Azure 或 Google GCP。
  缓存和全文搜索--Redis 是缓存键值对的常见选择。Elasticsearch 用于全文搜索。
- 通信--对于服务间的相互通信，我们可以使用 Kafka 或 RPC 消息传递。
- 持久性--我们可以使用 MySQL 或 PostgreSQL 作为关系数据库，亚马逊 S3 作为对象存储。如有必要，我们还可以使用 Cassandra 进行宽列存储。
- 管理与监控--为了管理这么多微服务，常用的运维工具包括 Prometheus、Elastic Stack 和 Kubernetes。

### Why is Kafka fast

Kafka 的性能得益于许多设计决策。在本篇文章中，我们将重点讨论其中两项。我们认为这两项决定的分量最重。

<p>
  <img src="images/why_is_kafka_fast.jpeg" />
</p>

1. 首先是 Kafka 对顺序 I/O 的依赖。
2. 赋予 Kafka 性能优势的第二个设计选择是它对效率的关注：零拷贝原则。

下图说明了数据如何在生产者和消费者之间传输，以及零拷贝的含义。

- 步骤 1.1 - 1.3：生产者将数据写入磁盘 
- 步骤 2：消费者读取数据，不进行零拷贝

2.1 数据从磁盘加载到操作系统缓存

2.2 数据从操作系统缓存复制到 Kafka 应用程序

2.3 Kafka 应用程序将数据复制到套接字缓冲区 

2.4 数据从套接字缓冲区复制到网卡

2.5 网卡将数据发送给消费者


- 步骤3：消费者通过零拷贝读取数据

3.1: 数据从磁盘加载到操作系统缓存
3.2 操作系统缓存通过 sendfile() 命令直接将数据拷贝到网卡上
3.3 网卡向用户发送数据

零拷贝是保存应用程序上下文和内核上下文之间多次数据拷贝的快捷方式。

## Payment systems

### How to learn payment systems?

<p>
  <img src="images/learn-payments.jpg" />
</p>

### Why is the credit card called “the most profitable product in banks”? How does VISA/Mastercard make money? 

<p>
  <img src="images/how does visa makes money.jpg" style="width: 640px" />
</p>

1.&nbsp;&nbsp;持卡人向商家支付 100 美元购买产品。

2.&nbsp;&nbsp;商户因使用信用卡提高了销售量而受益，并需要向发卡行和信用卡网络支付报酬。收单银行向商户收取一定费用，称为 "商户折扣费"。

3-4.收单银行保留 0.25 美元作为收单加价，1.75 美元作为交换费支付给发卡银行。商户折扣费应包含交换费。交换费由银行卡网络确定，因为每家发卡银行与每个商户协商费用的效率较低。

5.银行卡网络与每家银行确定网络分摊额和费用，银行每月向银行卡网络支付服务费。例如，VISA 对每次刷卡收取 0.11% 的分摊费，外加 0.0195 美元的使用费。

6.&nbsp;&nbsp;持卡人向发卡银行支付服务费。

为什么要补偿发卡银行？

- 即使持卡人未向发卡行付款，发卡行也会向商户付款。
- 在持卡人向发卡行付款之前，发卡行先向商户付款。
- 发卡行还有其他运营成本，包括管理客户账户、提供对账单、欺诈检测、风险管理、清算和结算等。

### How does VISA work when we swipe a credit card at a merchant’s shop?

<p>
  <img src="images/visa_payment.jpeg" />
</p>

VISA 卡、万事达卡和美国运通卡是清算和结算资金的银行卡网络。收卡银行和发卡银行可以是不同的，而且往往是不同的。如果银行在没有中间人的情况下逐一结算交易，那么每家银行都必须与所有其他银行结算交易。这样做效率很低。  

下图显示了 VISA 在信用卡支付流程中的作用。其中涉及两个流程。客户刷卡时发生授权流。捕获和结算流程发生在商户希望在一天结束时拿到钱的时候。

- 授权流程

步骤 0：发卡银行向客户发行信用卡。

第 1 步：持卡人要购买商品，在商户店内的销售点（POS）终端刷卡。

第 2 步：POS 终端将交易发送给提供 POS 终端的收单银行。

第 3 步和第 4 步：收单银行将交易发送到银行卡网络，也称为银行卡计划。银行卡网络将交易发送给发卡银行审批。

步骤 4.1、4.2 和 4.3： 如果交易获得批准，发卡银行将冻结资金。批准或拒绝的信息将发回收单银行和 POS 终端。

- 抓取和结算流程

步骤 1 和 2：商户希望在一天结束时收款，因此在 POS 终端上点击 "抓取"。交易被批量发送到收单机构。收单机构将交易批次文件发送给银行卡网络。

第三步：银行卡网络对从不同收单机构收集的交易进行清算，并将清算文件发送给不同的发卡银行。

步骤 4：发卡银行确认清算文件无误后，向相关收单银行转账。

第五步：收单银行将钱转给商户的银行。

第四步：银行卡网络清算来自不同收单银行的交易。清算是对相互抵消的交易进行净额结算，从而减少交易总数的过程。

在此过程中，银行卡网络承担了与每家银行对话的负担，并收取服务费作为回报。

Payment Systems Around The World Series (Part 1): Unified Payments Interface (UPI) in India

什么是 UPI？UPI 是印度国家支付公司开发的即时实时支付系统。

目前，它占印度数字零售交易的 60%。

UPI = 支付标记语言 + 互操作支付标准

<p>
  <img src="images/how-does-upi-work.png"  style="width: 600px" />
</p>

## DevOps

### DevOps vs. SRE vs. Platform Engineering. What is the difference?

DevOps、SRE 和平台工程的概念出现于不同时期，由不同的个人和组织发展而来。

<p>
  <img src="images/devops-sre-platform.jpg" />
</p>

DevOps 这一概念是 Patrick Debois 和 Andrew Shafer 于 2009 年在敏捷大会上提出的。他们试图通过促进协作文化和整个软件开发生命周期的责任分担，来弥合软件开发与运营之间的差距。

SRE 或称 "站点可靠性工程"（Site Reliability Engineering），由谷歌于 2000 年代初首创，旨在解决管理大规模复杂系统时遇到的运营挑战。谷歌开发了 SRE 实践和工具，如 Borg 集群管理系统和 Monarch 监控系统，以提高其服务的可靠性和效率。

平台工程是一个较新的概念，建立在 SRE 工程的基础之上。平台工程的确切起源不太清楚，但一般认为它是 DevOps 和 SRE 实践的延伸，重点是为产品开发提供一个支持整个业务视角的综合平台。

值得注意的是，虽然这些概念出现的时间不同。它们都与改善软件开发和运营中的协作、自动化和效率这一更广泛的趋势有关。

### What is k8s (Kubernetes)?

K8s 是一个容器协调系统。它用于容器部署和管理。它的设计深受谷歌内部系统 Borg 的影响。

<p>
  <img src="images/k8s.jpeg" style="width: 680px" />
</p>

k8s 集群由一组运行容器化应用程序的工作机器（称为节点）组成。每个集群至少有一个工作节点。

工作节点承载着作为应用工作负载组件的 Pod。控制平面管理集群中的工作节点和 Pod。在生产环境中，控制平面通常在多台计算机上运行，集群通常运行多个节点，以提供容错和高可用性。

- 控制平面组件

1. API 服务器

   API 服务器与 k8s 集群中的所有组件对话。Pod 上的所有操作都是通过与 API 服务器对话来执行的。

2. 调度程序

   调度程序负责监控 pod 的工作负载，并为新创建的 pod 分配负载。

3. 控制器管理器

   控制器管理器运行控制器，包括节点控制器、作业控制器、EndpointSlice 控制器和 ServiceAccount 控制器。

4. etcd

   etcd 是一个键值存储，用作 Kubernetes 所有集群数据的后备存储。

- 节点

1. pod

   Pod 是一组容器，是 k8s 管理的最小单位。Pod 中的每个容器都有一个 IP 地址。

2. Kubelet

   在集群中每个节点上运行的代理。它确保容器在 Pod 中运行。

### Docker vs. Kubernetes. Which one should we use? 

<p>
  <img src="images/docker-vs-k8s.jpg" style="width: 680px" />
</p>

什么是 Docker？

Docker 是一个开源平台，可让你在隔离的容器中打包、分发和运行应用程序。它专注于容器化，提供封装应用程序及其依赖关系的轻量级环境。

什么是 Kubernetes？

Kubernetes 通常被称为 K8s，是一个开源容器编排平台。它为在节点集群中自动部署、扩展和管理容器化应用程序提供了一个框架。

两者有何不同？

Docker Docker 在单个操作系统主机上的单个容器级别上运行。

你必须手动管理每台主机，为多个相关容器设置网络、安全策略和存储可能会很复杂。

Kubernetes Kubernetes 在集群级别运行。它跨多台主机管理多个容器化应用程序，为负载平衡、扩展和确保应用程序的理想状态等任务提供自动化。

简而言之，Docker 专注于容器化和在单个主机上运行容器，而 Kubernetes 则擅长在主机集群中大规模管理和协调容器。

### How does Docker work? 

下图展示了 Docker 的架构，以及当我们运行 "docker build"、"docker pull" 和 "docker run "时的运行情况。

<p>
  <img src="images/docker.jpg" style="width: 680px" />
</p>

Docker 架构中有 3 个组件： 

- Docker 客户端 

  Docker 客户端与 Docker 守护进程对话。

- Docker 主机 

  Docker 守护进程监听 Docker API 请求，并管理 Docker 对象，如镜像、容器、网络和卷。

- Docker 注册表 

  Docker 注册表存储 Docker 映像。Docker Hub 是一个公共注册表，任何人都可以使用。

让我们以 "docker run "命令为例。

  1. Docker 从注册表中提取映像。
  1. Docker 创建一个新容器。
  1. Docker 为容器分配一个读写文件系统。
  1. Docker 创建一个网络接口，将容器连接到默认网络。
  1. Docker 启动容器。

## GIT

### How Git Commands work

首先，必须确定代码的存储位置。通常的假设是只有两个位置，一个在 Github 等远程服务器上，另一个在我们的本地机器上。然而，这并不完全准确。Git 在我们的机器上有三个本地存储空间，这意味着我们的代码可以在四个地方找到：

<p>
  <img src="images/git-commands.png" style="width: 600px" />
</p>

- 工作目录：我们编辑文件的地方 
- 暂存区：为下一次提交保存文件的临时位置 
- 本地版本库：包含已提交的代码 
- 远程仓库：存储代码的远程服务器 

大多数 Git 命令主要是在这四个位置之间移动文件。

### How does Git Work?

<p>
  <img src="images/git-workflow.jpeg" style="width: 520px" />
</p>

Git 是一种分布式版本控制系统。

每个开发人员都维护一个主版本库的本地副本，并对本地副本进行编辑和提交。

由于提交操作不与远程版本库交互，因此提交速度非常快。

如果远程版本库崩溃，文件可以从本地版本库中恢复。

### Git merge vs. Git rebase

<p>
  <img src="images/git-merge-git-rebase.jpeg" style="width: 680px" />
</p>

当我们**从一个 Git 分支合并改动**到另一个分支时，可以使用 "git merge "或 "git rebase"。下图显示了这两个命令的工作原理。

**Git merge**

这将在主分支中创建一个新的提交 G'。G' 绑定了主分支和特性分支的历史。

Git 合并是**非破坏性**。主分支和特性分支都不会改变。

**Git rebase**

Git rebase 将特性分支的历史移到主分支的头部。它会为特性分支的每个提交创建新的提交 E'、F'和 G'。

rebase 的好处是它有一个线性的**提交历史**。

如果不遵守 "git rebase 黄金法则"，rebase 可能会有危险。

**Git Rebase 的黄金法则**

绝不在公共分支上使用！

## Cloud Services

### A nice cheat sheet of different cloud services (2023 edition)

<p>
  <img src="images/cloud-compare.jpg" />
</p>

### What is cloud native?

<p>
  <img src="images/cloud-native.jpeg" style="width: 640px" />
</p>

企业可以使用云原生技术在公共云、私有云和混合云上构建和运行可扩展的应用程序。

这意味着应用程序在设计上充分利用了云的功能，因此它们能够适应负载并易于扩展。

云原生包括 4 个方面： 

1. 开发流程 

   从瀑布式开发到敏捷开发再到 DevOps。

2. 应用架构 

   架构已从单体变为微服务。每个服务都设计得很小，以适应云容器中有限的资源。

3. 部署和打包 

   过去，应用程序部署在物理服务器上。2000 年左右，对延迟不敏感的应用程序通常部署在虚拟服务器上。而云原生应用程序则被打包成 docker 镜像并部署在容器中。

4. 应用程序基础设施 

   应用程序大量部署在云基础设施上，而不是自托管服务器上。

## Developer productivity tools

### Visualize JSON files

嵌套的 JSON 文件难以阅读。

**JsonCrack** 可从 JSON 文件生成图表，并使其易于阅读。

此外，生成的图表还可以作为图片下载。

<p>
  <img src="images/json-cracker.jpeg" />
</p>

### Automatically turn code into architecture diagrams

<p>
  <img src="images/diagrams_as_code.jpeg" style="width: 640px" />
</p>

它能做什么？

- 用 Python 代码绘制云系统架构图。
- 也可直接在 Jupyter Notebook 中渲染图表。
- 无需设计工具。
- 支持以下提供商 AWS、Azure、GCP、Kubernetes、阿里云、甲骨文云等。

[Github repo](https://github.com/mingrammer/diagrams)

## Linux

### Linux file system explained

<p>
  <img src="images/linux-file-systems.jpg" style="width: 680px" />
</p>

过去，Linux 文件系统就像一个无序的小镇，人们随心所欲地建造自己的房屋。然而，1994 年，文件系统层次标准（FHS）的引入为 Linux 文件系统带来了秩序。

通过实施像 FHS 这样的标准，软件可以确保在不同的 Linux 发行版中采用一致的布局。不过，并非所有 Linux 发行版都严格遵守这一标准。它们通常会加入自己独特的元素或迎合特定的要求。
要熟练掌握这一标准，可以从探索开始。使用 "cd "等命令进行导航，使用 "ls "命令列出目录内容。将文件系统想象成一棵树，从根 (/) 开始。随着时间的推移，这将成为你的第二天性，使你成为一名熟练的 Linux 管理员。

### 18 Most-used Linux Commands You Should Know 

Linux 命令是与操作系统交互的指令。它们有助于管理文件、目录、系统进程和系统的许多其他方面。你需要熟悉这些命令，才能高效地浏览和维护基于 Linux 的系统。

下图显示了常用的 Linux 命令：

<p>
  <img src="images/18 Most-Used Linux Commands You Should Know-01.jpeg" style="width: 680px" />
</p>

- ls - List files and directories 
- cd - Change the current directory 
- mkdir - Create a new directory 
- rm - Remove files or directories 
- cp - Copy files or directories 
- mv - Move or rename files or directories 
- chmod - Change file or directory permissions 
- grep - Search for a pattern in files 
- find - Search for files and directories 
- tar - manipulate tarball archive files 
- vi - Edit files using text editors 
- cat - display the content of files 
- top - Display processes and resource usage 
- ps - Display processes information 
- kill - Terminate a process by sending a signal 
- du - Estimate file space usage 
- ifconfig - Configure network interfaces  
- ping - Test network connectivity between hosts 

## Security

### How does HTTPS work?

超文本传输协议安全（HTTPS）是超文本传输协议（HTTP）的扩展。HTTPS 使用传输层安全（TLS）传输加密数据。

<p>
  <img src="images/https.jpg" />
</p>

数据是如何加密和解密的？

第 1 步 - 客户端（浏览器）和服务器建立 TCP 连接。

第 2 步 - 客户端向服务器发送 "客户端你好 "信息。该信息包含一套必要的加密算法（密码套件）和它能支持的最新 TLS 版本。服务器回应一个 "服务器问候"，以便浏览器知道它是否支持这些算法和 TLS 版本。

然后，服务器向客户端发送 SSL 证书。证书包含公钥、主机名、有效期等信息。客户端验证证书。

第 3 步 - 验证 SSL 证书后，客户端生成会话密钥，并使用公开密钥对其进行加密。服务器收到加密的会话密钥后，用私钥解密。

第 4 步 - 既然客户端和服务器都持有相同的会话密钥（对称加密），加密数据就会在安全的双向通道中传输。

HTTPS 为什么要在数据传输过程中切换到对称加密？主要有两个原因：

1. 安全性： 非对称加密只能单向传输。这意味着，如果服务器尝试将加密数据发送回客户端，任何人都可以使用公钥解密数据。

2. 服务器资源： 非对称加密会增加大量数学开销。它不适合长时间的数据传输。

### Oauth 2.0 Explained With Simple Terms. 

OAuth 2.0 是一个强大而安全的框架，它允许不同的应用程序代表用户进行安全交互，而无需共享敏感凭据。

<p>
  <img src="images/oAuth2.jpg" />
</p>

参与 OAuth 的实体包括用户、服务器和身份提供者（IDP）。

OAuth 令牌能做什么？

使用 OAuth 时，你会得到一个代表你的身份和权限的 OAuth 令牌。这个令牌可以做几件重要的事情： 

单点登录（SSO）： 有了 OAuth 令牌，您只需登录一次，就可以登录多个服务或应用程序，让生活更轻松、更安全。

跨系统授权： OAuth 令牌可让你在不同系统间共享授权或访问权限，这样你就不必到处单独登录。

访问用户配置文件： 拥有 OAuth 令牌的应用程序可以访问您允许访问的用户配置文件的某些部分，但不会看到所有内容。

请记住，OAuth 2.0 的目的是保证您和您的数据安全，同时让您在不同应用程序和服务之间获得无缝、无忧的在线体验。

### Top 4 Forms of Authentication Mechanisms 

<p>
  <img src="images/top4-most-used-auth.jpg" />
</p>

1. SSH 密钥： 

   加密密钥用于安全访问远程系统和服务器 

1. OAuth 标记： 

   可在第三方应用程序上有限访问用户数据的令牌 

1. SSL 证书： 

   数字证书可确保服务器与客户端之间的安全加密通信 

1. 凭证： 

   用户认证信息用于验证和授予对各种系统和服务的访问权限

### Session, cookie, JWT, token, SSO, and OAuth 2.0 - what are they?

这些术语都与用户身份管理有关。当你登录一个网站时，你要声明你是谁（身份识别）。你的身份会得到验证（认证），并被授予必要的权限（授权）。过去已经提出了许多解决方案，而且这个清单还在不断扩大。

<p>
  <img src="images/session.jpeg" />
</p>

从简单到复杂，以下是我对用户身份管理的理解：

- WWW 身份验证是最基本的方法。浏览器会要求你输入用户名和密码。由于无法控制登录生命周期，这种方法如今已很少使用。

- 对登录生命周期进行更精细控制的方法是会话 Cookie。服务器保存会话存储，浏览器保存会话 ID。cookie 通常只适用于浏览器，对移动应用程序并不友好。

- 为了解决兼容性问题，可以使用令牌。客户端向服务器发送令牌，服务器验证令牌。缺点是令牌需要加密和解密，可能会比较耗时。

- JWT 是表示令牌的标准方式。这种信息可以验证和信任，因为它是数字签名的。由于 JWT 包含签名，因此无需在服务器端保存会话信息。

- 通过使用 SSO（单点登录），您只需登录一次即可登录多个网站。它使用 CAS（中央验证服务）来维护跨网站信息。

- 通过使用 OAuth 2.0，您可以授权一个网站访问您在另一个网站上的信息。

### How to store passwords safely in the database and how to validate a password? 

<p>
  <img src="images/salt.jpg" style="width: 720px" />
</p>

**不应该做的事情**

- 用纯文本存储密码不是一个好主意，因为任何有内部访问权限的人都可以看到密码。

- 直接存储密码哈希值是不够的，因为它会受到预计算攻击，如彩虹表。

- 为了减少预计算攻击，我们对密码进行加盐处理。

**什么是盐？**

根据 OWASP 准则，"盐是一个随机生成的唯一字符串，作为散列过程的一部分添加到每个密码中"。

**如何存储密码和盐？**

1. 每个密码的哈希结果都是唯一的。
1. 可以使用以下格式将密码存储到数据库中：hash(password + salt)。

**如何验证密码？**

验证密码的过程如下：

1. 客户输入密码。
1. 系统从数据库中获取相应的盐。
1. 系统将盐添加到密码中并对其进行散列。我们将散列值称为 H1。
1. 系统会比较 H1 和 H2，其中 H2 是存储在数据库中的散列值。如果两者相同，则密码有效。

### Explaining JSON Web Token (JWT) to a 10 year old Kid

<p>
  <img src="images/jwt.jpg" />
</p>

想象一下，你有一个叫做 JWT 的特殊盒子。在这个盒子里，有三个部分：标题、载荷信息和签名。

头部就像盒子外面的标签。它告诉我们这是什么类型的盒子，以及它是如何被保护的。它通常以一种名为 JSON 的格式编写，这只是一种使用大括号 { } 和冒号 : 来组织信息的方式。

载荷信息就像你要发送的实际信息或资讯。它可以是你的姓名、年龄或任何其他你想分享的数据。它也是以 JSON 格式编写的，因此很容易理解和使用。
现在，签名是保证 JWT 安全的关键。它就像一个特殊的印章，只有发送方才知道如何创建。签名是用密码创建的，有点像口令。该签名可确保在发送方不知情的情况下，任何人都无法篡改 JWT 的内容。

当你想把 JWT 发送给服务器时，你要把报头、载荷信息和签名放在盒子里。然后发送给服务器。服务器可以很容易地读取报头和有效载荷，从而了解您的身份和您想要做什么。

### How does Google Authenticator (or other types of 2-factor authenticators) work?

当启用双因素身份验证时，Google Authenticator 通常用于登录我们的账户。它如何保证安全？

Google Authenticator 是一种基于软件的身份验证器，可实现两步验证服务。下图提供了详细信息。

<p>
  <img src="images/google_authenticate.jpeg" />
</p>

其中涉及两个阶段：

- 阶段 1 - 用户启用 Google 两步验证。
- 阶段 2 - 用户使用验证器登录等。

让我们来看看这些阶段。

**阶段 1**

步骤 1 和 2：鲍勃打开网页启用两步验证。前端请求一个秘钥。验证服务为鲍勃生成秘钥，并将其存储在数据库中。

步骤 3：验证服务向前端返回一个 URI。URI 由密钥发放者、用户名和秘钥组成。URI 以 QR 码的形式显示在网页上。

步骤 4：然后，鲍勃使用 Google Authenticator 扫描生成的 QR 码。秘钥存储在验证器中。

**第二阶段***
第 1 步和第 2 步：鲍勃想通过谷歌两步验证登录一个网站。为此，他需要密码。每隔 30 秒，谷歌身份验证器就会使用 TOTP（基于时间的一次性密码）算法生成一个 6 位数的密码。鲍勃使用密码进入网站。

步骤 3 和 4：前台将鲍勃输入的密码发送到后台进行身份验证。身份验证服务从数据库中读取秘钥，并使用与客户端相同的 TOTP 算法生成一个 6 位数密码。

步骤 5：身份验证服务比较客户端和服务器生成的两个密码，并将比较结果返回前端。只有当两个密码匹配时，鲍勃才能继续登录。

这种认证机制安全吗？

- 秘钥能否被他人获取？

  我们需要确保使用 HTTPS 传输秘钥。验证器客户端和数据库都会存储秘钥，我们需要确保秘钥是加密的。

- 黑客能猜出 6 位数密码吗？

  不会。密码有 6 位数字，因此生成的密码有 100 万种可能的组合。此外，密码每 30 秒就会更改一次。如果黑客想在 30 秒内猜出密码，他们每秒需要输入 30,000 个密码组合。

## Real World Case Studies

### Netflix's Tech Stack

本文章基于对许多 Netflix 工程博客和开源项目的研究。如果您发现任何不准确之处，请随时告知我们。

<p>
  <img src="images/netflix tech stack.png" style="width: 680px" />
</p>

**移动和网络**： Netflix 采用 Swift 和 Kotlin 构建本地移动应用程序。在网络应用方面，它使用了 React。

**前端/服务器通信**： Netflix 使用 GraphQL。

**后端服务**： Netflix依赖于ZUUL、Eureka、Spring Boot框架和其他技术。

**数据库**： Netflix 使用 EV cache、Cassandra、CockroachDB 和其他数据库。

**信息传递/流媒体**： Netflix 采用 Apache Kafka 和 Fink 进行消息传递和流媒体处理。

**视频存储**： Netflix 使用 S3 和 Open Connect 进行视频存储。

**数据处理**： Netflix 使用 Flink 和 Spark 进行数据处理，然后使用 Tableau 将数据可视化。Redshift 用于处理结构化数据仓库信息。

**CI/CD**： Netflix 在 CI/CD 流程中使用了 JIRA、Confluence、PagerDuty、Jenkins、Gradle、Chaos Monkey、Spinnaker、Atlas 等多种工具。

### Twitter Architecture 2022

没错，这就是真正的 Twitter 架构。它是由埃隆-马斯克发布的，我们重新绘制了它，以提高可读性。

<p>
  <img src="images/twitter-arch.jpeg" />
</p>

### Evolution of Airbnb’s microservice architecture over the past 15 years

<p>
  <img src="images/airbnb_arch.jpeg" />
</p>

巨石（2008 - 2017）

Airbnb 最初只是一个为房东和客人提供服务的简单市场。它由一个 Ruby on Rails 应用程序构建而成，即单体。

挑战是什么？

- 混乱的团队所有权+无所有权代码
- 部署缓慢 

微服务（2017-2020 年）

微服务旨在解决这些挑战。在微服务架构中，关键服务包括

- 数据获取服务
- 业务逻辑数据服务
- 编写工作流服务
- 用户界面聚合服务
- 每个服务都有一个拥有团队

挑战是什么？

数以百计的服务和依赖关系难以人为管理。

微服务+宏服务（2020 年至今）

这就是 Airbnb 目前正在努力的方向。微服务和宏服务混合模式的重点是统一 API。

### Monorepo vs. Microrepo. 

<p>
  <img src="images/monorepo-microrepo.jpg" />
</p>

Monorepo 并不新鲜；Linux 和 Windows 都是使用 Monorepo 创建的。为了提高可扩展性和构建速度，谷歌开发了内部专用工具链以加快扩展速度，并制定了严格的编码质量标准以保持一致性。

亚马逊和 Netflix 是微服务理念的主要代言人。这种方法自然而然地将服务代码分离到不同的资源库中。它的扩展速度更快，但也可能导致日后的治理痛点。

在 Monorepo 中，每个服务都是一个文件夹，每个文件夹都有 BUILD 配置和 OWNERS 权限控制。每个服务成员负责自己的文件夹。

另一方面，在 Microrepo 中，每个服务负责自己的资源库，通常为整个资源库设置构建配置和权限。

在 Monorepo 中，依赖关系在整个代码库中共享，与业务无关，因此当版本升级时，每个代码库都会升级自己的版本。

在 Microrepo 中，依赖关系受控于每个版本库。企业可根据自己的时间表选择何时升级版本。

Monorepo 有一个签入标准。谷歌的代码审查流程以设置高标准而闻名，这确保了 Monorepo 的质量标准一致，无论业务如何。

Microrepo 既可以制定自己的标准，也可以通过采纳最佳实践来采用共享标准。它可以更快地扩展业务，但代码质量可能会有些不同。
谷歌工程师开发了 Bazel，Meta 开发了 Buck。还有其他开源工具，包括 Nx、Lerna 等。

多年来，Microrepo 已拥有更多支持工具，包括用于 Java 的 Maven 和 Gradle、用于 NodeJS 的 NPM 和用于 C/C++ 的 CMake 等。

### How will you design the Stack Overflow website? 

如果你的答案是内部部署服务器和单片机（如下图底部），你很可能无法通过面试，但这就是现实中的构建方式！

<p>
  <img src="images/stackoverflow.jpg" />
</p>

**人们认为应该是什么样子**

面试官可能期待的是图片上半部分的样子。

- 微服务用于将系统分解成小的组件。
- 每个服务都有自己的数据库。大量使用缓存。
- 服务是分片的。
- 服务之间通过消息队列异步对话。
- 使用 CQRS 的事件源实现服务。
- 展示分布式系统知识，如最终一致性、CAP 定理等。

**实际情况**

Stack Overflow 仅使用 9 台内部网络服务器为所有流量提供服务，而且是单体式的！它有自己的服务器，不在云上运行。

这与我们现在流行的观点背道而驰。

### Why did Amazon Prime Video monitoring move from serverless to monolithic? How can it save 90% cost?

<p>
  <img src="images/serverless-to-monolithic.jpeg" />
</p>

什么是亚马逊 Prime 视频监控服务？

Prime Video 服务需要监控数千个实时流媒体的质量。监控工具会自动实时分析流媒体，并识别块损坏、视频冻结和同步问题等质量问题。这是保证客户满意度的重要流程。

共有 3 个步骤：媒体转换器、缺陷检测器和实时通知。

- 旧架构有什么问题？

  旧架构基于亚马逊 Lambda，这有利于快速构建服务。但是，在大规模运行该架构时，其成本效益并不高。最昂贵的两个操作是 

1. 协调工作流--AWS 步进函数通过状态转换向用户收费，协调每秒执行多个状态转换。

2. 分布式组件之间的数据传递--中间数据存储在亚马逊 S3 中，以便下一阶段下载。当数据量较大时，下载的成本会很高。

- 单体架构可节省 90% 的成本 

  单体架构旨在解决成本问题。虽然仍有 3 个组件，但媒体转换器和缺陷检测器部署在同一流程中，从而节省了通过网络传输数据的成本。令人惊讶的是，这种部署架构变革方法节省了 90% 的成本！

这是一个有趣而独特的案例研究，因为微服务已成为科技行业的首选和时尚。令人欣慰的是，我们正在对架构的发展进行更多的讨论，并对其利弊进行更坦诚的讨论。将组件分解成分布式微服务是有代价的。

- 亚马逊的领导们对此有何看法？

  亚马逊首席技术官维尔纳-沃格尔斯（Werner Vogels）： "构建**可扩展的软件系统**是一种战略，而不是一种信仰。以开放的心态重新审视你的架构是必须的"。

亚马逊前可持续发展副总裁阿德里安-科克罗夫特："Prime Video 团队走的是一条我称之为**无服务器优先**的道路......我不提倡**无服务器优先**。

### How does Disney Hotstar capture 5 Billion Emojis during a tournament?

<p>
  <img src="images/hotstar_emojis.jpeg" style="width: 720px" />
</p>

1. 客户端通过标准 HTTP 请求发送表情符号。您可以将 Golang 服务视为典型的 Web 服务器。之所以选择 Golang，是因为它能很好地支持并发性。Golang 中的线程是轻量级的。

2. 由于写入量非常大，因此使用 Kafka（消息队列）作为缓冲区。

3. Emoji 数据由名为 Spark 的流式处理服务聚合。它每 2 秒钟聚合一次数据，这是可配置的。需要根据时间间隔进行权衡。更短的间隔意味着表情符号能更快地传送到其他客户端，但也意味着需要更多的计算资源。

4. 汇总数据将写入另一个 Kafka。

5. PubSub 消费者从 Kafka 中提取汇总的表情符号数据。

6. 表情符号通过 PubSub 基础设施实时传送到其他客户端。PubSub 基础设施非常有趣。Hotstar 考虑了以下协议： Socketio、NATS、MQTT 和 gRPC，最终选择了 MQTT。

LinkedIn 也采用了类似的设计，该公司每秒可发送一百万个 "赞"。

### How Discord Stores Trillions Of Messages 

<p>
  <img src="images/discord-store-messages.jpg" />
</p>

MongoDB ➡️ Cassandra ➡️ ScyllaDB 

2015 年，Discord 的第一个版本建立在单个 MongoDB 复制之上。2015 年 11 月左右，MongoDB 存储了 1 亿条消息，RAM 无法再容纳数据和索引。延迟变得不可预测。消息存储需要转移到另一个数据库。Cassandra 被选中。

2017 年，Discord 拥有 12 个 Cassandra 节点，存储了数十亿条消息。

2022 年初，它拥有 177 个节点，存储了数万亿条消息。此时，延迟变得难以预测，维护操作的运行成本也变得过于昂贵。

造成这一问题有几个原因： 

- Cassandra 使用 LSM 树作为内部数据结构。读取比写入更昂贵。在一台拥有数百名用户的服务器上，可能会有很多并发读取，从而导致热点问题。
- 维护集群（如压缩 SSTables）会影响性能。
- 垃圾回收暂停会造成明显的延迟峰值 

ScyllaDB 是用 C++ 编写的 Cassandra 兼容数据库。Discord 重新设计了自己的架构，采用单片式 API、用 Rust 编写的数据服务和基于 ScyllaDB 的存储。

ScyllaDB 的 p99 读取延迟为 15 毫秒，而 Cassandra 为 40-125 毫秒。p99 的写延迟为 5ms，而 Cassandra 为 5-70ms。

### How do video live streamings work on YouTube, TikTok live, or Twitch?

实时流媒体与普通流媒体不同，因为视频内容是通过互联网实时发送的，延迟时间通常只有几秒钟。

下图解释了实现这一功能的幕后原理。

<p>
  <img src="images/live_streaming_updated.jpg" style="width: 640px" />
</p>

步骤 1：原始视频数据由麦克风和摄像头采集。数据被发送到服务器端。

步骤 2：对视频数据进行压缩和编码。例如，压缩算法会分离背景和其他视频元素。压缩后，视频按照 H.264 等标准进行编码。经过这一步骤后，视频数据的大小会小得多。

第三步：编码后的数据被分成更小的片段，长度通常为几秒钟，因此下载或流式传输所需的时间更短。

步骤 4：将分段数据发送到流媒体服务器。流媒体服务器需要支持不同的设备和网络条件。这就是所谓的 "自适应比特率流"。这意味着我们需要在步骤 2 和 3 中以不同的比特率生成多个文件。

第 5 步：将流媒体直播数据推送到 CDN（内容分发网络）支持的边缘服务器。CDN 大大降低了数据传输延迟。

步骤 6：观众的设备对视频数据进行解码和解压，并在视频播放器中播放视频。

第 7 步和第 8 步：如果视频需要存储以便重放，则将编码数据发送到存储服务器，观众可以稍后请求重放。

实时流媒体的标准协议包括

- RTMP（实时信息传输协议）： 最初由 Macromedia 开发，用于在 Flash 播放器和服务器之间传输数据。现在，它用于在互联网上传输视频数据流。请注意，Skype 等视频会议应用程序使用 RTC（实时通信）协议来降低延迟。
- HLS（HTTP 实时流）： 它需要 H.264 或 H.265 编码。苹果设备只接受 HLS 格式。
- DASH（HTTP 动态自适应流媒体）： DASH 不支持苹果设备。
- HLS 和 DASH 都支持自适应比特率流。